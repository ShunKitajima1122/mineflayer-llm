"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovementSimulations = void 0;
const mineflayer_physics_util_1 = require("@nxg-org/mineflayer-physics-util");
const BasicMoves = [
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT(),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("forward", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("forward", true).set("right", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("forward", true).set("left", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("back", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("back", true).set("left", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("back", true).set("right", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("left", true),
    mineflayer_physics_util_1.ControlStateHandler.DEFAULT().set("right", true),
];
/**
 * To be used once per movement.
 *
 * Provide state that will serve as a base. The state itself will not be modified/consumed unless called for.
 */
class MovementSimulations {
    constructor(bot, ctx) {
        this.bot = bot;
        this.ctx = ctx;
    }
    *predictGenerator(ctx, world, ticks = 1, controls) {
        ctx.state.control = controls !== null && controls !== void 0 ? controls : mineflayer_physics_util_1.ControlStateHandler.DEFAULT();
        for (let current = 0; current < ticks; current++) {
            yield this.ctx.simulate(ctx, world);
        }
        return ctx;
    }
    predictForward(target, world, ticks = 1, controls) {
        const ctx = mineflayer_physics_util_1.EPhysicsCtx.FROM_ENTITY(this.ctx, target);
        ctx.state.control = controls !== null && controls !== void 0 ? controls : mineflayer_physics_util_1.ControlStateHandler.DEFAULT();
        for (let current = 0; current < ticks; current++) {
            this.ctx.simulate(ctx, world);
        }
        return ctx;
    }
    findCorrectMovements(lastState, world, wantedPos) {
        // console.log("TEST\n===========================\ndelta pos:",wantedPos.minus(lastState.position), '\nstate\'s vel:', lastState.velocity, '\nstate\'s position:', lastState.position, '\nwanted position:', wantedPos)
        const defaultCtx = lastState.clone();
        const destinations = [];
        for (const move of BasicMoves) {
            const testCtx = defaultCtx.clone();
            testCtx.state.control = move.clone();
            this.ctx.simulate(testCtx, world);
            destinations.push([testCtx.position, testCtx.state.control]);
        }
        const flag = !defaultCtx.state.isUsingItem;
        const flag2 = defaultCtx.state.onGround || defaultCtx.state.isInWater || defaultCtx.state.isInLava;
        const flag3 = flag && flag2;
        // Apply sprint tests.
        // Only apply if moving forward AND not sneaking AND state not using item.
        if (flag) {
            for (const move of BasicMoves.filter(ctrl => ctrl.forward === true && ctrl.sneak === false && ctrl.back === false)) {
                const testCtx = defaultCtx.clone();
                testCtx.state.control = move.clone().set("sprint", true);
                this.ctx.simulate(testCtx, world);
                destinations.push([testCtx.position, testCtx.state.control]);
            }
        }
        // Apply jump, sneak, and jump-sneak tests.
        // Only test this if jump is relevant. Otherwise, ignore.
        if (flag2) {
            for (const move of BasicMoves) {
                const testCtx = defaultCtx.clone();
                testCtx.state.control = move.clone().set("jump", true);
                this.ctx.simulate(testCtx, world);
                destinations.push([testCtx.position, testCtx.state.control]);
            }
            for (const move of BasicMoves) {
                const testState1 = defaultCtx.clone();
                testState1.state.control = move.clone().set("sneak", true);
                this.ctx.simulate(testState1, world);
                destinations.push([testState1.position, testState1.state.control]);
            }
            for (const move of BasicMoves) {
                const testState2 = defaultCtx.clone();
                testState2.state.control = move.clone().set("jump", true).set("sneak", true);
                this.ctx.simulate(testState2, world);
                destinations.push([testState2.position, testState2.state.control]);
            }
        }
        // Apply sprint-jump tests.
        // Only apply if entity is on the ground, NOT shifting, and NOT holding backward.
        if (flag3) {
            for (const move of BasicMoves.filter(ctrl => ctrl.forward === true && ctrl.sneak === false && ctrl.back === false)) {
                const testState = defaultCtx.clone();
                testState.state.control = move.clone().set("sprint", true).set("jump", true);
                this.ctx.simulate(testState, world);
                destinations.push([testState.position, testState.state.control]);
            }
        }
        const closestControls = destinations.sort((a, b) => a[0].distanceTo(wantedPos) - b[0].distanceTo(wantedPos));
        return closestControls[0][1];
    }
}
exports.MovementSimulations = MovementSimulations;
